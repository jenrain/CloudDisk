{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FunctionParser = exports.dedentFunction = exports.functionToString = exports.USED_METHOD_KEY = void 0;\n\nconst quote_1 = require(\"./quote\");\n/**\n * Used in function stringification.\n */\n\n/* istanbul ignore next */\n\n\nconst METHOD_NAMES_ARE_QUOTED = {\n  \" \"() {\n    /* Empty. */\n  }\n\n}[\" \"].toString().charAt(0) === '\"';\nconst FUNCTION_PREFIXES = {\n  Function: \"function \",\n  GeneratorFunction: \"function* \",\n  AsyncFunction: \"async function \",\n  AsyncGeneratorFunction: \"async function* \"\n};\nconst METHOD_PREFIXES = {\n  Function: \"\",\n  GeneratorFunction: \"*\",\n  AsyncFunction: \"async \",\n  AsyncGeneratorFunction: \"async *\"\n};\nconst TOKENS_PRECEDING_REGEXPS = new Set((\"case delete else in instanceof new return throw typeof void \" + \", ; : + - ! ~ & | ^ * / % < > ? =\").split(\" \"));\n/**\n * Track function parser usage.\n */\n\nexports.USED_METHOD_KEY = new WeakSet();\n/**\n * Stringify a function.\n */\n\nconst functionToString = (fn, space, next, key) => {\n  const name = typeof key === \"string\" ? key : undefined; // Track in function parser for object stringify to avoid duplicate output.\n\n  if (name !== undefined) exports.USED_METHOD_KEY.add(fn);\n  return new FunctionParser(fn, space, next, name).stringify();\n};\n\nexports.functionToString = functionToString;\n/**\n * Rewrite a stringified function to remove initial indentation.\n */\n\nfunction dedentFunction(fnString) {\n  let found;\n\n  for (const line of fnString.split(\"\\n\").slice(1)) {\n    const m = /^[\\s\\t]+/.exec(line);\n    if (!m) return fnString; // Early exit without indent.\n\n    const [str] = m;\n    if (found === undefined) found = str;else if (str.length < found.length) found = str;\n  }\n\n  return found ? fnString.split(`\\n${found}`).join(\"\\n\") : fnString;\n}\n\nexports.dedentFunction = dedentFunction;\n/**\n * Function parser and stringify.\n */\n\nclass FunctionParser {\n  constructor(fn, indent, next, key) {\n    this.fn = fn;\n    this.indent = indent;\n    this.next = next;\n    this.key = key;\n    this.pos = 0;\n    this.hadKeyword = false;\n    this.fnString = Function.prototype.toString.call(fn);\n    this.fnType = fn.constructor.name;\n    this.keyQuote = key === undefined ? \"\" : quote_1.quoteKey(key, next);\n    this.keyPrefix = key === undefined ? \"\" : `${this.keyQuote}:${indent ? \" \" : \"\"}`;\n    this.isMethodCandidate = key === undefined ? false : this.fn.name === \"\" || this.fn.name === key;\n  }\n\n  stringify() {\n    const value = this.tryParse(); // If we can't stringify this function, return a void expression; for\n    // bonus help with debugging, include the function as a string literal.\n\n    if (!value) {\n      return `${this.keyPrefix}void ${this.next(this.fnString)}`;\n    }\n\n    return dedentFunction(value);\n  }\n\n  getPrefix() {\n    if (this.isMethodCandidate && !this.hadKeyword) {\n      return METHOD_PREFIXES[this.fnType] + this.keyQuote;\n    }\n\n    return this.keyPrefix + FUNCTION_PREFIXES[this.fnType];\n  }\n\n  tryParse() {\n    if (this.fnString[this.fnString.length - 1] !== \"}\") {\n      // Must be an arrow function.\n      return this.keyPrefix + this.fnString;\n    } // Attempt to remove function prefix.\n\n\n    if (this.fn.name) {\n      const result = this.tryStrippingName();\n      if (result) return result;\n    } // Support class expressions.\n\n\n    const prevPos = this.pos;\n    if (this.consumeSyntax() === \"class\") return this.fnString;\n    this.pos = prevPos;\n\n    if (this.tryParsePrefixTokens()) {\n      const result = this.tryStrippingName();\n      if (result) return result;\n      let offset = this.pos;\n\n      switch (this.consumeSyntax(\"WORD_LIKE\")) {\n        case \"WORD_LIKE\":\n          if (this.isMethodCandidate && !this.hadKeyword) {\n            offset = this.pos;\n          }\n\n        case \"()\":\n          if (this.fnString.substr(this.pos, 2) === \"=>\") {\n            return this.keyPrefix + this.fnString;\n          }\n\n          this.pos = offset;\n\n        case '\"':\n        case \"'\":\n        case \"[]\":\n          return this.getPrefix() + this.fnString.substr(this.pos);\n      }\n    }\n  }\n  /**\n   * Attempt to parse the function from the current position by first stripping\n   * the function's name from the front. This is not a fool-proof method on all\n   * JavaScript engines, but yields good results on Node.js 4 (and slightly\n   * less good results on Node.js 6 and 8).\n   */\n\n\n  tryStrippingName() {\n    if (METHOD_NAMES_ARE_QUOTED) {\n      // ... then this approach is unnecessary and yields false positives.\n      return;\n    }\n\n    let start = this.pos;\n    const prefix = this.fnString.substr(this.pos, this.fn.name.length);\n\n    if (prefix === this.fn.name) {\n      this.pos += prefix.length;\n\n      if (this.consumeSyntax() === \"()\" && this.consumeSyntax() === \"{}\" && this.pos === this.fnString.length) {\n        // Don't include the function's name if it will be included in the\n        // prefix, or if it's invalid as a name in a function expression.\n        if (this.isMethodCandidate || !quote_1.isValidVariableName(prefix)) {\n          start += prefix.length;\n        }\n\n        return this.getPrefix() + this.fnString.substr(start);\n      }\n    }\n\n    this.pos = start;\n  }\n  /**\n   * Attempt to advance the parser past the keywords expected to be at the\n   * start of this function's definition. This method sets `this.hadKeyword`\n   * based on whether or not a `function` keyword is consumed.\n   */\n\n\n  tryParsePrefixTokens() {\n    let posPrev = this.pos;\n    this.hadKeyword = false;\n\n    switch (this.fnType) {\n      case \"AsyncFunction\":\n        if (this.consumeSyntax() !== \"async\") return false;\n        posPrev = this.pos;\n\n      case \"Function\":\n        if (this.consumeSyntax() === \"function\") {\n          this.hadKeyword = true;\n        } else {\n          this.pos = posPrev;\n        }\n\n        return true;\n\n      case \"AsyncGeneratorFunction\":\n        if (this.consumeSyntax() !== \"async\") return false;\n\n      case \"GeneratorFunction\":\n        let token = this.consumeSyntax();\n\n        if (token === \"function\") {\n          token = this.consumeSyntax();\n          this.hadKeyword = true;\n        }\n\n        return token === \"*\";\n    }\n  }\n  /**\n   * Advance the parser past one element of JavaScript syntax. This could be a\n   * matched pair of delimiters, like braces or parentheses, or an atomic unit\n   * like a keyword, variable, or operator. Return a normalized string\n   * representation of the element parsed--for example, returns '{}' for a\n   * matched pair of braces. Comments and whitespace are skipped.\n   *\n   * (This isn't a full parser, so the token scanning logic used here is as\n   * simple as it can be. As a consequence, some things that are one token in\n   * JavaScript, like decimal number literals or most multi-character operators\n   * like '&&', are split into more than one token here. However, awareness of\n   * some multi-character sequences like '=>' is necessary, so we match the few\n   * of them that we care about.)\n   */\n\n\n  consumeSyntax(wordLikeToken) {\n    const m = this.consumeMatch(/^(?:([A-Za-z_0-9$\\xA0-\\uFFFF]+)|=>|\\+\\+|\\-\\-|.)/);\n    if (!m) return;\n    const [token, match] = m;\n    this.consumeWhitespace();\n    if (match) return wordLikeToken || match;\n\n    switch (token) {\n      case \"(\":\n        return this.consumeSyntaxUntil(\"(\", \")\");\n\n      case \"[\":\n        return this.consumeSyntaxUntil(\"[\", \"]\");\n\n      case \"{\":\n        return this.consumeSyntaxUntil(\"{\", \"}\");\n\n      case \"`\":\n        return this.consumeTemplate();\n\n      case '\"':\n        return this.consumeRegExp(/^(?:[^\\\\\"]|\\\\.)*\"/, '\"');\n\n      case \"'\":\n        return this.consumeRegExp(/^(?:[^\\\\']|\\\\.)*'/, \"'\");\n    }\n\n    return token;\n  }\n\n  consumeSyntaxUntil(startToken, endToken) {\n    let isRegExpAllowed = true;\n\n    for (;;) {\n      const token = this.consumeSyntax();\n      if (token === endToken) return startToken + endToken;\n      if (!token || token === \")\" || token === \"]\" || token === \"}\") return;\n\n      if (token === \"/\" && isRegExpAllowed && this.consumeMatch(/^(?:\\\\.|[^\\\\\\/\\n[]|\\[(?:\\\\.|[^\\]])*\\])+\\/[a-z]*/)) {\n        isRegExpAllowed = false;\n        this.consumeWhitespace();\n      } else {\n        isRegExpAllowed = TOKENS_PRECEDING_REGEXPS.has(token);\n      }\n    }\n  }\n\n  consumeMatch(re) {\n    const m = re.exec(this.fnString.substr(this.pos));\n    if (m) this.pos += m[0].length;\n    return m;\n  }\n  /**\n   * Advance the parser past an arbitrary regular expression. Return `token`,\n   * or the match object of the regexp.\n   */\n\n\n  consumeRegExp(re, token) {\n    const m = re.exec(this.fnString.substr(this.pos));\n    if (!m) return;\n    this.pos += m[0].length;\n    this.consumeWhitespace();\n    return token;\n  }\n  /**\n   * Advance the parser past a template string.\n   */\n\n\n  consumeTemplate() {\n    for (;;) {\n      this.consumeMatch(/^(?:[^`$\\\\]|\\\\.|\\$(?!{))*/);\n\n      if (this.fnString[this.pos] === \"`\") {\n        this.pos++;\n        this.consumeWhitespace();\n        return \"`\";\n      }\n\n      if (this.fnString.substr(this.pos, 2) === \"${\") {\n        this.pos += 2;\n        this.consumeWhitespace();\n        if (this.consumeSyntaxUntil(\"{\", \"}\")) continue;\n      }\n\n      return;\n    }\n  }\n  /**\n   * Advance the parser past any whitespace or comments.\n   */\n\n\n  consumeWhitespace() {\n    this.consumeMatch(/^(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/);\n  }\n\n}\n\nexports.FunctionParser = FunctionParser;","map":{"version":3,"mappings":"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","names":["METHOD_NAMES_ARE_QUOTED","toString","charAt","FUNCTION_PREFIXES","Function","GeneratorFunction","AsyncFunction","AsyncGeneratorFunction","METHOD_PREFIXES","TOKENS_PRECEDING_REGEXPS","Set","split","exports","WeakSet","functionToString","fn","space","next","key","name","undefined","add","FunctionParser","stringify","dedentFunction","fnString","found","line","slice","m","exec","str","length","join","constructor","indent","prototype","call","fnType","keyQuote","quote_1","keyPrefix","isMethodCandidate","value","tryParse","getPrefix","hadKeyword","result","tryStrippingName","prevPos","pos","consumeSyntax","tryParsePrefixTokens","offset","substr","start","prefix","posPrev","token","wordLikeToken","consumeMatch","match","consumeWhitespace","consumeSyntaxUntil","consumeTemplate","consumeRegExp","startToken","endToken","isRegExpAllowed","has","re"],"sourceRoot":"","sources":["../src/function.ts"],"sourcesContent":["import { Next, ToString } from \"./types\";\nimport { quoteKey, isValidVariableName } from \"./quote\";\n\n/**\n * Used in function stringification.\n */\n/* istanbul ignore next */\nconst METHOD_NAMES_ARE_QUOTED =\n  {\n    \" \"() {\n      /* Empty. */\n    },\n  }[\" \"]\n    .toString()\n    .charAt(0) === '\"';\n\nconst FUNCTION_PREFIXES = {\n  Function: \"function \",\n  GeneratorFunction: \"function* \",\n  AsyncFunction: \"async function \",\n  AsyncGeneratorFunction: \"async function* \",\n};\n\nconst METHOD_PREFIXES = {\n  Function: \"\",\n  GeneratorFunction: \"*\",\n  AsyncFunction: \"async \",\n  AsyncGeneratorFunction: \"async *\",\n};\n\nconst TOKENS_PRECEDING_REGEXPS = new Set(\n  (\n    \"case delete else in instanceof new return throw typeof void \" +\n    \", ; : + - ! ~ & | ^ * / % < > ? =\"\n  ).split(\" \")\n);\n\n/**\n * Track function parser usage.\n */\nexport const USED_METHOD_KEY = new WeakSet<(...args: unknown[]) => unknown>();\n\n/**\n * Stringify a function.\n */\nexport const functionToString: ToString = (fn, space, next, key) => {\n  const name = typeof key === \"string\" ? key : undefined;\n\n  // Track in function parser for object stringify to avoid duplicate output.\n  if (name !== undefined) USED_METHOD_KEY.add(fn);\n\n  return new FunctionParser(fn, space, next, name).stringify();\n};\n\n/**\n * Rewrite a stringified function to remove initial indentation.\n */\nexport function dedentFunction(fnString: string) {\n  let found: string | undefined;\n\n  for (const line of fnString.split(\"\\n\").slice(1)) {\n    const m = /^[\\s\\t]+/.exec(line);\n    if (!m) return fnString; // Early exit without indent.\n\n    const [str] = m;\n\n    if (found === undefined) found = str;\n    else if (str.length < found.length) found = str;\n  }\n\n  return found ? fnString.split(`\\n${found}`).join(\"\\n\") : fnString;\n}\n\n/**\n * Function parser and stringify.\n */\nexport class FunctionParser {\n  fnString: string;\n  fnType: keyof typeof FUNCTION_PREFIXES;\n  keyQuote: string | undefined;\n  keyPrefix: string;\n  isMethodCandidate: boolean;\n\n  pos = 0;\n  hadKeyword = false;\n\n  constructor(\n    public fn: (...args: unknown[]) => unknown,\n    public indent: string,\n    public next: Next,\n    public key?: string\n  ) {\n    this.fnString = Function.prototype.toString.call(fn);\n    this.fnType = fn.constructor.name as keyof typeof FUNCTION_PREFIXES;\n    this.keyQuote = key === undefined ? \"\" : quoteKey(key, next);\n    this.keyPrefix =\n      key === undefined ? \"\" : `${this.keyQuote}:${indent ? \" \" : \"\"}`;\n    this.isMethodCandidate =\n      key === undefined ? false : this.fn.name === \"\" || this.fn.name === key;\n  }\n\n  stringify() {\n    const value = this.tryParse();\n\n    // If we can't stringify this function, return a void expression; for\n    // bonus help with debugging, include the function as a string literal.\n    if (!value) {\n      return `${this.keyPrefix}void ${this.next(this.fnString)}`;\n    }\n\n    return dedentFunction(value);\n  }\n\n  getPrefix() {\n    if (this.isMethodCandidate && !this.hadKeyword) {\n      return METHOD_PREFIXES[this.fnType] + this.keyQuote;\n    }\n\n    return this.keyPrefix + FUNCTION_PREFIXES[this.fnType];\n  }\n\n  tryParse() {\n    if (this.fnString[this.fnString.length - 1] !== \"}\") {\n      // Must be an arrow function.\n      return this.keyPrefix + this.fnString;\n    }\n\n    // Attempt to remove function prefix.\n    if (this.fn.name) {\n      const result = this.tryStrippingName();\n      if (result) return result;\n    }\n\n    // Support class expressions.\n    const prevPos = this.pos;\n    if (this.consumeSyntax() === \"class\") return this.fnString;\n    this.pos = prevPos;\n\n    if (this.tryParsePrefixTokens()) {\n      const result = this.tryStrippingName();\n      if (result) return result;\n\n      let offset = this.pos;\n\n      switch (this.consumeSyntax(\"WORD_LIKE\")) {\n        case \"WORD_LIKE\":\n          if (this.isMethodCandidate && !this.hadKeyword) {\n            offset = this.pos;\n          }\n        case \"()\":\n          if (this.fnString.substr(this.pos, 2) === \"=>\") {\n            return this.keyPrefix + this.fnString;\n          }\n\n          this.pos = offset;\n        case '\"':\n        case \"'\":\n        case \"[]\":\n          return this.getPrefix() + this.fnString.substr(this.pos);\n      }\n    }\n  }\n\n  /**\n   * Attempt to parse the function from the current position by first stripping\n   * the function's name from the front. This is not a fool-proof method on all\n   * JavaScript engines, but yields good results on Node.js 4 (and slightly\n   * less good results on Node.js 6 and 8).\n   */\n  tryStrippingName() {\n    if (METHOD_NAMES_ARE_QUOTED) {\n      // ... then this approach is unnecessary and yields false positives.\n      return;\n    }\n\n    let start = this.pos;\n    const prefix = this.fnString.substr(this.pos, this.fn.name.length);\n\n    if (prefix === this.fn.name) {\n      this.pos += prefix.length;\n\n      if (\n        this.consumeSyntax() === \"()\" &&\n        this.consumeSyntax() === \"{}\" &&\n        this.pos === this.fnString.length\n      ) {\n        // Don't include the function's name if it will be included in the\n        // prefix, or if it's invalid as a name in a function expression.\n        if (this.isMethodCandidate || !isValidVariableName(prefix)) {\n          start += prefix.length;\n        }\n\n        return this.getPrefix() + this.fnString.substr(start);\n      }\n    }\n\n    this.pos = start;\n  }\n\n  /**\n   * Attempt to advance the parser past the keywords expected to be at the\n   * start of this function's definition. This method sets `this.hadKeyword`\n   * based on whether or not a `function` keyword is consumed.\n   */\n  tryParsePrefixTokens(): boolean {\n    let posPrev = this.pos;\n\n    this.hadKeyword = false;\n\n    switch (this.fnType) {\n      case \"AsyncFunction\":\n        if (this.consumeSyntax() !== \"async\") return false;\n\n        posPrev = this.pos;\n      case \"Function\":\n        if (this.consumeSyntax() === \"function\") {\n          this.hadKeyword = true;\n        } else {\n          this.pos = posPrev;\n        }\n        return true;\n      case \"AsyncGeneratorFunction\":\n        if (this.consumeSyntax() !== \"async\") return false;\n      case \"GeneratorFunction\":\n        let token = this.consumeSyntax();\n\n        if (token === \"function\") {\n          token = this.consumeSyntax();\n          this.hadKeyword = true;\n        }\n\n        return token === \"*\";\n    }\n  }\n\n  /**\n   * Advance the parser past one element of JavaScript syntax. This could be a\n   * matched pair of delimiters, like braces or parentheses, or an atomic unit\n   * like a keyword, variable, or operator. Return a normalized string\n   * representation of the element parsed--for example, returns '{}' for a\n   * matched pair of braces. Comments and whitespace are skipped.\n   *\n   * (This isn't a full parser, so the token scanning logic used here is as\n   * simple as it can be. As a consequence, some things that are one token in\n   * JavaScript, like decimal number literals or most multi-character operators\n   * like '&&', are split into more than one token here. However, awareness of\n   * some multi-character sequences like '=>' is necessary, so we match the few\n   * of them that we care about.)\n   */\n  consumeSyntax(wordLikeToken?: string) {\n    const m = this.consumeMatch(\n      /^(?:([A-Za-z_0-9$\\xA0-\\uFFFF]+)|=>|\\+\\+|\\-\\-|.)/\n    );\n\n    if (!m) return;\n\n    const [token, match] = m;\n    this.consumeWhitespace();\n\n    if (match) return wordLikeToken || match;\n\n    switch (token) {\n      case \"(\":\n        return this.consumeSyntaxUntil(\"(\", \")\");\n      case \"[\":\n        return this.consumeSyntaxUntil(\"[\", \"]\");\n      case \"{\":\n        return this.consumeSyntaxUntil(\"{\", \"}\");\n      case \"`\":\n        return this.consumeTemplate();\n      case '\"':\n        return this.consumeRegExp(/^(?:[^\\\\\"]|\\\\.)*\"/, '\"');\n      case \"'\":\n        return this.consumeRegExp(/^(?:[^\\\\']|\\\\.)*'/, \"'\");\n    }\n\n    return token;\n  }\n\n  consumeSyntaxUntil(startToken: string, endToken: string): string | undefined {\n    let isRegExpAllowed = true;\n\n    for (;;) {\n      const token = this.consumeSyntax();\n      if (token === endToken) return startToken + endToken;\n      if (!token || token === \")\" || token === \"]\" || token === \"}\") return;\n\n      if (\n        token === \"/\" &&\n        isRegExpAllowed &&\n        this.consumeMatch(/^(?:\\\\.|[^\\\\\\/\\n[]|\\[(?:\\\\.|[^\\]])*\\])+\\/[a-z]*/)\n      ) {\n        isRegExpAllowed = false;\n        this.consumeWhitespace();\n      } else {\n        isRegExpAllowed = TOKENS_PRECEDING_REGEXPS.has(token);\n      }\n    }\n  }\n\n  consumeMatch(re: RegExp) {\n    const m = re.exec(this.fnString.substr(this.pos));\n    if (m) this.pos += m[0].length;\n    return m;\n  }\n\n  /**\n   * Advance the parser past an arbitrary regular expression. Return `token`,\n   * or the match object of the regexp.\n   */\n  consumeRegExp(re: RegExp, token: string): string | undefined {\n    const m = re.exec(this.fnString.substr(this.pos));\n    if (!m) return;\n    this.pos += m[0].length;\n    this.consumeWhitespace();\n    return token;\n  }\n\n  /**\n   * Advance the parser past a template string.\n   */\n  consumeTemplate() {\n    for (;;) {\n      this.consumeMatch(/^(?:[^`$\\\\]|\\\\.|\\$(?!{))*/);\n\n      if (this.fnString[this.pos] === \"`\") {\n        this.pos++;\n        this.consumeWhitespace();\n        return \"`\";\n      }\n\n      if (this.fnString.substr(this.pos, 2) === \"${\") {\n        this.pos += 2;\n        this.consumeWhitespace();\n\n        if (this.consumeSyntaxUntil(\"{\", \"}\")) continue;\n      }\n\n      return;\n    }\n  }\n\n  /**\n   * Advance the parser past any whitespace or comments.\n   */\n  consumeWhitespace() {\n    this.consumeMatch(/^(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}