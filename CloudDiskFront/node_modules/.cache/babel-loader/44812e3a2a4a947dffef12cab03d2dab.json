{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\nconst ChainedMap = require('./ChainedMap');\n\nconst Orderable = require('./Orderable');\n\nmodule.exports = Orderable(class extends ChainedMap {\n  constructor(parent, name, type = 'plugin') {\n    super(parent);\n    this.name = name;\n    this.type = type;\n    this.extend(['init']);\n    this.init((Plugin, args = []) => {\n      if (typeof Plugin === 'function') {\n        return new Plugin(...args);\n      }\n\n      return Plugin;\n    });\n  }\n\n  use(plugin, args = []) {\n    return this.set('plugin', plugin).set('args', args);\n  }\n\n  tap(f) {\n    if (!this.has('plugin')) {\n      throw new Error(`Cannot call .tap() on a plugin that has not yet been defined. Call ${this.type}('${this.name}').use(<Plugin>) first.`);\n    }\n\n    this.set('args', f(this.get('args') || []));\n    return this;\n  }\n\n  set(key, value) {\n    if (key === 'args' && !Array.isArray(value)) {\n      throw new Error('args must be an array of arguments');\n    }\n\n    return super.set(key, value);\n  }\n\n  merge(obj, omit = []) {\n    if ('plugin' in obj) {\n      this.set('plugin', obj.plugin);\n    }\n\n    if ('args' in obj) {\n      this.set('args', obj.args);\n    }\n\n    return super.merge(obj, [...omit, 'args', 'plugin']);\n  }\n\n  toConfig() {\n    const init = this.get('init');\n    let plugin = this.get('plugin');\n    const args = this.get('args');\n    let pluginPath = null;\n\n    if (plugin === undefined) {\n      throw new Error(`Invalid ${this.type} configuration: ${this.type}('${this.name}').use(<Plugin>) was not called to specify the plugin`);\n    } // Support using the path to a plugin rather than the plugin itself,\n    // allowing expensive require()s to be skipped in cases where the plugin\n    // or webpack configuration won't end up being used.\n\n\n    if (typeof plugin === 'string') {\n      pluginPath = plugin; // eslint-disable-next-line global-require, import/no-dynamic-require\n\n      plugin = require(pluginPath);\n    }\n\n    const constructorName = plugin.__expression ? `(${plugin.__expression})` : plugin.name;\n    const config = init(plugin, args);\n    Object.defineProperties(config, {\n      __pluginName: {\n        value: this.name\n      },\n      __pluginType: {\n        value: this.type\n      },\n      __pluginArgs: {\n        value: args\n      },\n      __pluginConstructorName: {\n        value: constructorName\n      },\n      __pluginPath: {\n        value: pluginPath\n      }\n    });\n    return config;\n  }\n\n});","map":{"version":3,"names":["ChainedMap","require","Orderable","module","exports","constructor","parent","name","type","extend","init","Plugin","args","use","plugin","set","tap","f","has","Error","get","key","value","Array","isArray","merge","obj","omit","toConfig","pluginPath","undefined","constructorName","__expression","config","Object","defineProperties","__pluginName","__pluginType","__pluginArgs","__pluginConstructorName","__pluginPath"],"sources":["D:/Desktop/cloud-disk-front/node_modules/webpack-chain/src/Plugin.js"],"sourcesContent":["const ChainedMap = require('./ChainedMap');\nconst Orderable = require('./Orderable');\n\nmodule.exports = Orderable(\n  class extends ChainedMap {\n    constructor(parent, name, type = 'plugin') {\n      super(parent);\n      this.name = name;\n      this.type = type;\n      this.extend(['init']);\n\n      this.init((Plugin, args = []) => {\n        if (typeof Plugin === 'function') {\n          return new Plugin(...args);\n        }\n        return Plugin;\n      });\n    }\n\n    use(plugin, args = []) {\n      return this.set('plugin', plugin).set('args', args);\n    }\n\n    tap(f) {\n      if (!this.has('plugin')) {\n        throw new Error(\n          `Cannot call .tap() on a plugin that has not yet been defined. Call ${this.type}('${this.name}').use(<Plugin>) first.`,\n        );\n      }\n      this.set('args', f(this.get('args') || []));\n      return this;\n    }\n\n    set(key, value) {\n      if (key === 'args' && !Array.isArray(value)) {\n        throw new Error('args must be an array of arguments');\n      }\n      return super.set(key, value);\n    }\n\n    merge(obj, omit = []) {\n      if ('plugin' in obj) {\n        this.set('plugin', obj.plugin);\n      }\n\n      if ('args' in obj) {\n        this.set('args', obj.args);\n      }\n\n      return super.merge(obj, [...omit, 'args', 'plugin']);\n    }\n\n    toConfig() {\n      const init = this.get('init');\n      let plugin = this.get('plugin');\n      const args = this.get('args');\n      let pluginPath = null;\n\n      if (plugin === undefined) {\n        throw new Error(\n          `Invalid ${this.type} configuration: ${this.type}('${this.name}').use(<Plugin>) was not called to specify the plugin`,\n        );\n      }\n\n      // Support using the path to a plugin rather than the plugin itself,\n      // allowing expensive require()s to be skipped in cases where the plugin\n      // or webpack configuration won't end up being used.\n      if (typeof plugin === 'string') {\n        pluginPath = plugin;\n        // eslint-disable-next-line global-require, import/no-dynamic-require\n        plugin = require(pluginPath);\n      }\n\n      const constructorName = plugin.__expression\n        ? `(${plugin.__expression})`\n        : plugin.name;\n\n      const config = init(plugin, args);\n\n      Object.defineProperties(config, {\n        __pluginName: { value: this.name },\n        __pluginType: { value: this.type },\n        __pluginArgs: { value: args },\n        __pluginConstructorName: { value: constructorName },\n        __pluginPath: { value: pluginPath },\n      });\n\n      return config;\n    }\n  },\n);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}